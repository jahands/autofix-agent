---
description:
globs: AutofixAgent.ts
alwaysApply: false
---
# AutofixAgent Architecture Overview

This document outlines the architecture of the `AutofixAgent`, located in [`apps/autofix/src/AutofixAgent.ts`](mdc:apps/autofix/src/AutofixAgent.ts). The agent is designed to automate fixes in Cloudflare Workers projects by managing a lifecycle of actions, with built-in indefinite retries for transient issues, interruptions, or action failures.

**Core Components & Logic:**

*   **`AutofixAgent` Class:** The primary class extending `Agent` from the Cloudflare Agents SDK. It manages the agent's lifecycle and state.
*   **State Management (`AgentState`):**
    *   Defines the agent's state, including:
        *   `repo: string`
        *   `branch: string`
        *   `currentAction: AgentAction` (Zod enum representing lifecycle stages: `idle`, `initialize_container`, `detect_issues`, `fix_issues`, `commit_changes`, `push_changes`, `create_pr`, `finish`, `handle_error`).
        *   `progress: ProgressStatus` (Zod enum: `idle`, `retry`, `running`, `success`, `failed`). `'retry'` indicates an action is ready to be (re)tried.
        *   `lastStatusUpdateTimestamp: number`
        *   `errorDetails?: { message: string; failedAction: AgentAction }` (optional context for errors).
    *   State is persisted using `this.setState()`.
    *   Notably, `currentActionAttempts` and related maximum attempt constants have been removed. Retries are indefinite.
*   **`currentActionPromise: Promise<void> | undefined`:** A private instance variable holding the promise of the currently executing action handler's callback. This is used to detect if a Durable Object restart might have interrupted an ongoing action.

**Alarm-Driven Processing:**

*   The agent's main work loop is triggered by alarms managed via `this.ctx.storage.setAlarm()` and handled by the `onAlarm()` method.
*   `setNextAlarm()` is a private helper method to schedule subsequent alarms.

**`onAlarm()` Method:** This is the heart of the agent. It operates on the live `this.state`.

*   **Interruption Check:**
    *   At the start, if `this.state.progress === 'running'` and `this.currentActionPromise === undefined`, it assumes the Durable Object may have restarted during the action.
    *   It sets the `progress` of `this.state.currentAction` to `'retry'` and updates `errorDetails`. The main `match` statement will then handle this `'retry'` state.
*   `setNextAlarm()` is called early in the `onAlarm` execution.
*   **Local Helper Functions (defined within `onAlarm`):**
    *   `setRunning(newAction: AgentAction)`:
        *   Updates the agent's state: `currentAction` to `newAction`, `progress` to `'running'`.
        *   Logs the start of the action.
    *   `runActionHandler(actionToRun: AgentAction, callback: () => Promise<void>)`:
        *   Calls `setRunning(actionToRun)`.
        *   Assigns the `callback()` promise to `this.currentActionPromise`.
        *   Executes the `callback` in a `try/catch/finally` block:
            *   On success, calls `this.setActionOutcome({ progress: 'success' })`.
            *   On error, calls `this.setActionOutcome({ progress: 'failed', error: e })`.
            *   In `finally`, sets `this.currentActionPromise = undefined`.
*   **Timeout Check:** This has been **removed**. Actions do not time out based on their own execution duration anymore.
*   **State Machine (using `ts-pattern`'s `match` on `this.state`):**
    *   **Sequential Transitions & Retry Handling:** The primary way actions are started or retried. Uses combined clauses:
        *   Example:
            ```typescript
            .with(
                { currentAction: 'previous_action_name', progress: 'success' }, // Previous completed
                { currentAction: 'current_action_name', progress: 'retry' },  // OR current is marked for retry
                () => runActionHandler('current_action_name', () => this.handleCurrentActionName())
            )
            ```
        *   This pattern is applied for all steps.
    *   **`finish/success`**: Transitions to `idle/idle` state by calling `this.setState()` (clears `errorDetails`).
    *   **`handle_error/success`**: Transitions to `idle/idle` state similarly (clears `errorDetails` if error handling was itself successful).
    *   **Generic Failed Action Handler (`currentAction: P.not(P.union('idle', 'handle_error')), progress: 'failed'`)**:
        *   This handles actions that explicitly fail (handler throws an error).
        *   Logs the failure and unconditionally calls `this.setState()` to change `progress` to `'retry'`. `errorDetails` are preserved. The action will be retried on the next alarm via the combined clauses mentioned above.
    *   **`handle_error/retry`**: If `handle_error` itself was interrupted and is now in a retry state, this clause calls `runActionHandler('handle_error', () => this.handleError())` to retry it.
    *   **`handle_error/failed`**: If `handle_error` fails, logs a critical error and calls `this.setState()` to transition to `idle/idle` to prevent loops, preserving `errorDetails`.
    *   **`.../running`**: If an action is `running` (and hasn't been interrupted), it logs this and waits for the next alarm.
    *   **Anomalous States**:
        *   `idle` with `progress` other than `idle`: Logs a warning, sets state to `idle/idle`.
        *   Non-`idle` action with `progress: 'idle'`: Logs a warning, sets the action's `progress` to `'retry'`, and updates `errorDetails` to note the anomalous recovery. This allows the standard retry mechanism to pick it up.
    *   The `match` statement is `.exhaustive()`.

**Action Handlers (`handle[ActionName]()`):**

*   Private `async` methods corresponding to most `AgentAction` values.
*   Perform core operational logic. They should throw errors on failure, caught by `runActionHandler`.
*   They **do not** call `this.setActionOutcome()` directly.

**`setActionOutcome()` Method:**

*   A private helper method to standardize setting the outcome of an action.
*   Signature: `setActionOutcome(options: { progress: 'success' } | { progress: 'failed'; error: Error | unknown }): void` (returns `void`).
*   Updates `lastStatusUpdateTimestamp` and `progress`.
*   If `options.progress === 'success'`:
    *   Clears `errorDetails`.
    *   Logs success.
*   If `options.progress === 'failed'`:
    *   Sets `errorDetails` with the error message and `failedAction`.
    *   Logs the failure. Error variable named `e` or `err` in implementation.

**Logging:**

*   The agent uses a `logger` instance (from `workers-tagged-logger`) initialized in the constructor and pre-tagged.
*   `@WithLogTags` decorator is used on `start()` and `onAlarm()`.
*   Specific `this.logger.info/warn/error` calls are used throughout for detailed operational logging (replacing previous `console.error/warn` for consistency).
*   Comments follow stylistic preferences: lowercase for single sentences, capitalized for multi-sentence.

**Key Workflow Patterns:**

1.  **Start:** `start()` initializes state to `idle` and schedules the first alarm.
2.  **Alarm & Interruption:** `onAlarm()` triggers. Checks for interruptions. If an action is interrupted, its state becomes `retry`.
3.  **State Matching (`match` in `onAlarm`):**
    *   (`idle/idle` OR `some_action/retry`) -> `runActionHandler('some_action', ...)`.
    *   (`previous_action/success` OR `current_action/retry`) -> `runActionHandler('current_action', ...)`.
    *   (`action_X/failed` and not `idle` or `handle_error`) -> sets `action_X` to `retry`. Next alarm cycle triggers retry.
    *   `finish/success` or `handle_error/success` -> `idle/idle`.
    *   `handle_error/failed` -> `idle/idle` (preserving error details).
4.  **Action Execution (`runActionHandler`):** `setRunning()` updates state. Handler logic executes.
5.  **Outcome Setting (`setActionOutcome`):** Called by `runActionHandler` to record outcome.
6.  **Loop:** Repeats with the next alarm. Actions are retried indefinitely upon interruption or explicit failure.

This architecture aims for a simplified, resilient state machine where actions retry indefinitely, relying on external observation for persistently problematic loops.
